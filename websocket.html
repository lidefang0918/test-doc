<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket 实时通信 | ruoyi-vue-pro 开发指南</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            border-bottom: 1px solid #eee;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        .source-url {
            color: #666;
            font-size: 14px;
            margin-top: 10px;
        }
        .content-wrapper {
            line-height: 1.8;
        }
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px 0;
        }
        pre {
            background: #f6f8fa;
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
        }
        code {
            background: #f6f8fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>WebSocket 实时通信 | ruoyi-vue-pro 开发指南</h1>
        <div class="source-url">原始链接: <a href="https://doc.iocoder.cn/websocket/">https://doc.iocoder.cn/websocket/</a></div>
    </div>
    <div class="content-wrapper">
        <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">WebSocket 实时通信<!----></h1>  <div class="theme-vdoing-content content__default"><h2 id="_1-功能简介"><a href="#_1-%E5%8A%9F%E8%83%BD%E7%AE%80%E4%BB%8B" class="header-anchor">#</a> 1. 功能简介</h2> <p>项目的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/tree/master/yudao-framework/yudao-spring-boot-starter-websocket" target="_blank" rel="noopener noreferrer"><code>yudao-spring-boot-starter-websocket</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 组件，基于 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket" target="_blank" rel="noopener noreferrer">Spring WebSocket<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 进行二次封装，实现了更加简单的使用方式。例如说，WebSocket 的认证、Session 的管理、WebSocket 集群的消息广播等等。</p> <div class="custom-block tip"><p class="custom-block-title">疑问：为什么不使用 Netty 实现 WebSocket？</p> <p>Netty 的学习和使用门槛较高，对大家可能不够友好，而 Spring WebSocket 足够满足 99.99% 的场景。</p></div> <h3 id="_1-1-token-身份认证"><a href="#_1-1-token-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81" class="header-anchor">#</a> 1.1 Token 身份认证</h3> <p>① 在 WebSocket 连接建立时，通过 QueryString 的 <code>token</code> 参数，进行认证。例如说：<code>ws://127.0.0.1:48080/ws?token=xxx</code>。</p> <p>由于 WebSocket 是基于 HTTP 建立连接，所以它的认证可以复用项目的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-security/src/main/java/cn/iocoder/yudao/framework/security/core/filter/TokenAuthenticationFilter.java" target="_blank" rel="noopener noreferrer">TokenAuthenticationFilter<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 实现。</p> <div class="custom-block tip"><p class="custom-block-title">为什么 token 不使用 Header 传递？</p> <p>WebSocket 不支持 Header 传递，所以只能使用 QueryString 传递。</p></div> <p>② 认证完成后，会通过 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/security/LoginUserHandshakeInterceptor.java" target="_blank" rel="noopener noreferrer">LoginUserHandshakeInterceptor<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 拦截器，将用户信息存储到 WebSocket Session 的 <code>attributes</code> 中。</p> <p>这样，后续可以使用 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/util/WebSocketFrameworkUtils.java" target="_blank" rel="noopener noreferrer">WebSocketFrameworkUtils<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 获取用户信息，例如说：</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token comment">// WebSocketFrameworkUtils.java</span>

<span class="token comment">// ① 获取当前用户</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">LoginUser</span> <span class="token function">getLoginUser</span><span class="token punctuation">(</span><span class="token class-name">WebSocketSession</span> session<span class="token punctuation">)</span>

<span class="token comment">// ② 获得当前用户的类型</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">getLoginUserType</span><span class="token punctuation">(</span><span class="token class-name">WebSocketSession</span> session<span class="token punctuation">)</span>

<span class="token comment">// ③ 获得当前用户的编号</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">getLoginUserType</span><span class="token punctuation">(</span><span class="token class-name">WebSocketSession</span> session<span class="token punctuation">)</span>

<span class="token comment">// ④ 获得当前用户的租户编号</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Long</span> <span class="token function">getTenantId</span><span class="token punctuation">(</span><span class="token class-name">WebSocketSession</span> session<span class="token punctuation">)</span>
</code></pre></div><h3 id="_1-2-session-会话管理"><a href="#_1-2-session-%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86" class="header-anchor">#</a> 1.2 Session 会话管理</h3> <p>每个前端和后端建立的 WebSocket 连接，对应后端的一个 WebSocketSession 会话对象。由于后续需要对 WebSocketSession 进行消息的发送，所以需要进行管理。</p> <p>① WebSocketSession 的管理，由 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/session/WebSocketSessionManager.java" target="_blank" rel="noopener noreferrer">WebSocketSessionManager<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 定义接口，由 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/session/WebSocketSessionManagerImpl.java" target="_blank" rel="noopener noreferrer">WebSocketSessionManagerImpl<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 具体实现。</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token comment">// 添加和移除 Session</span>
<span class="token keyword">void</span> <span class="token function">addSession</span><span class="token punctuation">(</span><span class="token class-name">WebSocketSession</span> session<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">removeSession</span><span class="token punctuation">(</span><span class="token class-name">WebSocketSession</span> session<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获得 Session，多种维度</span>
<span class="token class-name">WebSocketSession</span> <span class="token function">getSession</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Session 编号</span>
<span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WebSocketSession</span><span class="token punctuation">&gt;</span></span> <span class="token function">getSessionList</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> userType<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用户类型</span>
<span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WebSocketSession</span><span class="token punctuation">&gt;</span></span> <span class="token function">getSessionList</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> userType<span class="token punctuation">,</span> <span class="token class-name">Long</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用户编号</span>
</code></pre></div><p>② WebSocket 建立和关闭连接时，通过 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/session/WebSocketSessionHandlerDecorator.java" target="_blank" rel="noopener noreferrer">WebSocketSessionHandlerDecorator<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 处理器，分别调用 WebSocketSessionManager 进行 Session 的添加和移除。</p> <h3 id="_1-3-message-消息格式"><a href="#_1-3-message-%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F" class="header-anchor">#</a> 1.3 Message 消息格式</h3> <p>WebSocket 默认使用“文本”进行通信，而业务需要按照不同类型的消息，进行不同的处理。因此，项目定义了 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/message/JsonWebSocketMessage.java" target="_blank" rel="noopener noreferrer">JsonWebSocketMessage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息对象，包含 <code>type</code> 消息类型 + <code>content</code> 消息内容。</p> <p>和 Spring MVC 对比，可以理解为：</p> <table><thead><tr><th></th> <th>标识</th> <th>方法</th> <th>参数</th></tr></thead> <tbody><tr><td>Spring MVC</td> <td>URL + Method 等</td> <td>Controller 的 Method 方法</td> <td>QueryString 或 RequestBody 等</td></tr> <tr><td>项目 WebSocket</td> <td><code>type</code> 消息类型</td> <td><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/listener/WebSocketMessageListener.java" target="_blank" rel="noopener noreferrer">WebSocketMessageListener<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 实现类</td> <td>解析 <code>content</code> 消息内容后的 Message 对象</td></tr></tbody></table> <p>具体 JsonWebSocketMessage 和 WebSocketMessageListener 详细说明，参见「1.4 Message 消息接收」小节。</p> <h3 id="_1-4-message-消息接收"><a href="#_1-4-message-%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6" class="header-anchor">#</a> 1.4 Message 消息接收</h3> <p>① WebSocket 接收到项目后，会先交给 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/handler/JsonWebSocketMessageHandler.java" target="_blank" rel="noopener noreferrer">JsonWebSocketMessageHandler<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 消息处理器，将消息解析成 JsonWebSocketMessage 对象。</p> <p>之后，根据 <code>type</code> 消息类型，获得到 WebSocketMessageListener 实现类，并将 <code>content</code> 消息内容进一步解析成 Message 对象，交给它进行处理。</p> <p>② 具体案例，可见 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-infra/src/main/java/cn/iocoder/yudao/module/infra/websocket/DemoWebSocketMessageListener.java" target="_blank" rel="noopener noreferrer">DemoWebSocketMessageListener<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、<a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-infra/src/main/java/cn/iocoder/yudao/module/infra/websocket/message/DemoSendMessage.java" target="_blank" rel="noopener noreferrer">DemoSendMessage<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 类。</p> <h3 id="_1-5-message-消息推送"><a href="#_1-5-message-%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81" class="header-anchor">#</a> 1.5 Message 消息推送</h3> <p>① 项目的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-websocket/src/main/java/cn/iocoder/yudao/framework/websocket/core/sender/WebSocketMessageSender.java" target="_blank" rel="noopener noreferrer">WebSocketMessageSender<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 接口，定义了给 Session 发送消息的方法。如下所示：</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token comment">// WebSocketMessageSender.java</span>

<span class="token comment">// ① 发送消息给指定用户</span>
<span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> userType<span class="token punctuation">,</span> <span class="token class-name">Long</span> userId<span class="token punctuation">,</span> <span class="token class-name">String</span> messageType<span class="token punctuation">,</span> <span class="token class-name">String</span> messageContent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">sendObject</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> userType<span class="token punctuation">,</span> <span class="token class-name">Long</span> userId<span class="token punctuation">,</span> <span class="token class-name">String</span> messageType<span class="token punctuation">,</span> <span class="token class-name">Object</span> messageContent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">send</span><span class="token punctuation">(</span>userType<span class="token punctuation">,</span> userId<span class="token punctuation">,</span> messageType<span class="token punctuation">,</span> <span class="token class-name">JsonUtils</span><span class="token punctuation">.</span><span class="token function">toJsonString</span><span class="token punctuation">(</span>messageContent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ② 发送消息给指定用户类型</span>
<span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> userType<span class="token punctuation">,</span> <span class="token class-name">String</span> messageType<span class="token punctuation">,</span> <span class="token class-name">String</span> messageContent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">sendObject</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> userType<span class="token punctuation">,</span> <span class="token class-name">String</span> messageType<span class="token punctuation">,</span> <span class="token class-name">Object</span> messageContent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">send</span><span class="token punctuation">(</span>userType<span class="token punctuation">,</span> messageType<span class="token punctuation">,</span> <span class="token class-name">JsonUtils</span><span class="token punctuation">.</span><span class="token function">toJsonString</span><span class="token punctuation">(</span>messageContent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ③ 发送消息给指定 Session</span>
<span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> sessionId<span class="token punctuation">,</span> <span class="token class-name">String</span> messageType<span class="token punctuation">,</span> <span class="token class-name">String</span> messageContent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">sendObject</span><span class="token punctuation">(</span><span class="token class-name">String</span> sessionId<span class="token punctuation">,</span> <span class="token class-name">String</span> messageType<span class="token punctuation">,</span> <span class="token class-name">Object</span> messageContent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">send</span><span class="token punctuation">(</span>sessionId<span class="token punctuation">,</span> messageType<span class="token punctuation">,</span> <span class="token class-name">JsonUtils</span><span class="token punctuation">.</span><span class="token function">toJsonString</span><span class="token punctuation">(</span>messageContent<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>② WebSocketMessageSender 有多种实现类，如下：</p> <table><thead><tr><th>实现类</th> <th>是否支持 WebSocket 集群</th> <th>前置要求</th></tr></thead> <tbody><tr><td>LocalWebSocketMessageSender</td> <td>❌</td> <td>无</td></tr> <tr><td>RedisWebSocketMessageSender</td> <td>✅</td> <td>开启 <a href="/message-queue/redis/">《消息队列（Redis）》</a></td></tr> <tr><td>RocketMQWebSocketMessageSender</td> <td>✅</td> <td>开启 <a href="/message-queue/rocketmq/">《消息队列（RocketMQ）》</a></td></tr> <tr><td>KafkaWebSocketMessageSender</td> <td>✅</td> <td>开启 <a href="/message-queue/kafka/">《消息队列（Kafka）》</a></td></tr> <tr><td>RabbitMQWebSocketMessageSender</td> <td>✅</td> <td>开启 <a href="/message-queue/rabbitmq/">《消息队列（RabbitMQ）》</a></td></tr></tbody></table> <div class="custom-block tip"><p class="custom-block-title">疑问：什么是 WebSocket 集群？</p> <p>在后端部署多个 Java 进程时，会形成 WebSocket 集群。此时，就会存在跨进程的消息推送问题。例如说，连接 A 进程的 WebSocket 的用户，想要发送消息给连接 B 进程的 WebSocket 用户。</p> <p>😁 如何解决呢？消息不直接发送给用户 WebSocketSession，而是先发给 Redis、RocketMQ 等消息队列，再由每个 Java 进程监听该消息，分别判断判断该用户 WebSocket 是否连接的是自己，如果是，则进行消息推送。</p></div> <p>默认配置下，使用 LocalWebSocketMessageSender 本地发送消息，不支持 WebSocket 集群。可通过修改 <code>application.yaml</code> 配置文件的 <code>yudao.websocket.sender-type</code> 来切换，如下：</p> <div class="language-YAML extra-class"><pre class="language-yaml"><code><span class="token key atrule">yudao</span><span class="token punctuation">:</span>
  <span class="token key atrule">websocket</span><span class="token punctuation">:</span>
    <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># websocket的开关</span>
    <span class="token key atrule">path</span><span class="token punctuation">:</span> /infra/ws <span class="token comment"># 路径</span>
    <span class="token key atrule">sender-type</span><span class="token punctuation">:</span> redis <span class="token comment"># 消息发送的类型，可选值为 local、redis、rocketmq、kafka、rabbitmq</span>
    <span class="token key atrule">sender-rocketmq</span><span class="token punctuation">:</span>
      <span class="token key atrule">topic</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span><span class="token punctuation">-</span>websocket <span class="token comment"># 消息发送的 RocketMQ Topic</span>
      <span class="token key atrule">consumer-group</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span><span class="token punctuation">-</span>websocket<span class="token punctuation">-</span>consumer <span class="token comment"># 消息发送的 RocketMQ Consumer Group</span>
    <span class="token key atrule">sender-rabbitmq</span><span class="token punctuation">:</span>
      <span class="token key atrule">exchange</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span><span class="token punctuation">-</span>websocket<span class="token punctuation">-</span>exchange <span class="token comment"># 消息发送的 RabbitMQ Exchange</span>
      <span class="token key atrule">queue</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span><span class="token punctuation">-</span>websocket<span class="token punctuation">-</span>queue <span class="token comment"># 消息发送的 RabbitMQ Queue</span>
    <span class="token key atrule">sender-kafka</span><span class="token punctuation">:</span>
      <span class="token key atrule">topic</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span><span class="token punctuation">-</span>websocket <span class="token comment"># 消息发送的 Kafka Topic</span>
      <span class="token key atrule">consumer-group</span><span class="token punctuation">:</span> $<span class="token punctuation">{</span>spring.application.name<span class="token punctuation">}</span><span class="token punctuation">-</span>websocket<span class="token punctuation">-</span>consumer <span class="token comment"># 消息发送的 Kafka Consumer Group</span>
</code></pre></div><p>另外，默认的 WebSocket 连接地址是 <code>ws://127.0.0.1:48080/infra/ws</code>，可通过 <code>yudao.websocket.path</code> 配置项进行修改。</p> <h2 id="_2-使用方案"><a href="#_2-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%A1%88" class="header-anchor">#</a> 2. 使用方案</h2> <p>目前有 2 种使用方案，分别是：</p> <table><thead><tr><th>方案名</th> <th>上行</th> <th>下行</th></tr></thead> <tbody><tr><td>方案一：纯 WebSocket</td> <td>WebSocket</td> <td>WebSocket</td></tr> <tr><td>方案二：WebSocket + HTTP</td> <td>HTTP</td> <td>WebSocket</td></tr></tbody></table> <div class="custom-block tip"><p class="custom-block-title">疑问：什么是上行？什么是下行？</p> <ul><li>上行：指的是“前端”发送消息给“后端”，WebSocket 和 HTTP 都可以。</li> <li>下行：指的是“后端”发送消息给“前端”，只能使用 WebSocket。</li></ul></div> <div class="custom-block tip"><p class="custom-block-title">友情提示：下文中提到的所有配置，项目都已经配置好。你只需要按照下文的步骤，进行调试即可，了解每个配置的作用即可。</p></div> <h3 id="_2-1-方案一-纯-websocket"><a href="#_2-1-%E6%96%B9%E6%A1%88%E4%B8%80-%E7%BA%AF-websocket" class="header-anchor">#</a> 2.1 方案一：纯 WebSocket</h3> <p><img src="/img/WebSocket/WebSocket%E6%B5%8B%E8%AF%95%E7%95%8C%E9%9D%A2.png" alt="WebSocket 测试界面"></p> <ul><li>前端：见 [基础设施 -&gt; WebSocket 测试] 菜单，对应 <a href="https://github.com/yudaocode/yudao-ui-admin-vue3/blob/master/src/views/infra/webSocket/index.vue" target="_blank" rel="noopener noreferrer">/views/infra/websocket/index.vue<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 界面</li> <li>后端：见 <code>yudao-module-infra</code> 模块，对应 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-infra/src/main/java/cn/iocoder/yudao/module/infra/websocket/DemoWebSocketMessageListener.java" target="_blank" rel="noopener noreferrer">DemoWebSocketMessageListener<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 监听器</li></ul> <p>基于 WebSocket 实现的单聊和群聊，暂时不支持消息的持久化（刷新后，消息会消息）。建议，多多调试，更好的理解 WebSocket 流程。</p> <h4 id="_2-1-1-后端代码"><a href="#_2-1-1-%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81" class="header-anchor">#</a> 2.1.1 后端代码</h4> <p>① 在 <code>yudao-module-infra</code> 模块的 <code>pom.xml</code> 文件中，引入 <code>yudao-spring-boot-starter-websocket</code> 依赖。如下所示：</p> <div class="language-XML extra-class"><pre class="language-xml"><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.iocoder.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>yudao-spring-boot-starter-websocket<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>② 新建 DemoWebSocketMessageListener 类，实现对应消息的处理。如下图所示：</p> <div class="custom-block warning"><p class="custom-block-title">图片纠错：最新版本不区分 yudao-module-infra-api 和 yudao-module-infra-biz 子模块，代码直接合并到 yudao-module-infra 模块的 src 目录下，更适合单体项目</p></div> <p><img src="/img/WebSocket/DemoWebSocketMessageListener%E7%B1%BB.png" alt="DemoWebSocketMessageListener 类"></p> <h4 id="_2-1-2-前端代码"><a href="#_2-1-2-%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81" class="header-anchor">#</a> 2.1.2 前端代码</h4> <p>① 建立 WebSocket 连接，如下图所示：</p> <p><img src="/img/WebSocket/WebSocket%E8%BF%9E%E6%8E%A5.png" alt="WebSocket 连接"></p> <p>② 发送 WebSocket 消息，如下图所示：</p> <p><img src="/img/WebSocket/WebSocket%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF.png" alt="WebSocket 发送消息"></p> <p>③ 接收 WebSocket 消息。如下图所示：</p> <p><img src="/img/WebSocket/WebSocket%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF.png" alt="WebSocket 接收消息"></p> <h3 id="_2-2-方案二-websocket-http"><a href="#_2-2-%E6%96%B9%E6%A1%88%E4%BA%8C-websocket-http" class="header-anchor">#</a> 2.2 方案二：WebSocket + HTTP</h3> <p><img src="/img/WebSocket/%E5%85%AC%E5%91%8A%E9%80%9A%E7%9F%A5.png" alt="公告通知"></p> <ul><li>前端：见 [系统管理 -&gt; 消息中心 -&gt; 通知公告] 菜单，对应 <a href="https://github.com/yudaocode/yudao-ui-admin-vue3/blob/master/src/views/system/notice/index.vue" target="_blank" rel="noopener noreferrer">/views/system/notice/index.vue<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 界面的【推送】按钮</li> <li>后端：见 <code>yudao-module-system</code> 模块，对应 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-infra/src/main/java/cn/iocoder/yudao/module/infra/websocket/DemoWebSocketMessageListener.java" target="_blank" rel="noopener noreferrer">DemoWebSocketMessageListener<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 监听器</li></ul> <p>点击某条公告的【推送】按钮，仅仅推送给所有在线用户。由于 WebSocket 目前暂时没全局建立，所以还是使用 [基础设施 -&gt; WebSocket 测试] 菜单演示。如下图所示：</p> <p><img src="/img/WebSocket/%E5%85%AC%E5%91%8A%E9%80%9A%E7%9F%A5%E7%9A%84%E6%8E%A8%E9%80%81.png" alt="公告通知的推送"></p> <h4 id="_2-2-1-后端代码"><a href="#_2-2-1-%E5%90%8E%E7%AB%AF%E4%BB%A3%E7%A0%81" class="header-anchor">#</a> 2.2.1 后端代码</h4> <p>【相同】① 在 <code>yudao-module-infra</code> 模块的 <code>pom.xml</code> 文件中，引入 <code>yudao-spring-boot-starter-websocket</code> 依赖。</p> <p>【不同】② 在 <code>yudao-module-system</code> 模块的 <code>pom.xml</code> 文件中，引入 <code>yudao-module-infra</code> 依赖。如下所示：</p> <div class="language-XML extra-class"><pre class="language-xml"><code>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.iocoder.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>yudao-module-infra<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${revision}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>【不同】③ 在 <code>yudao-module-system</code> 模块，在 NoticeController 类中，新建 <code>#push(...)</code> 方法，用于推送公告消息。如下图所示：</p> <p><img src="/img/WebSocket/NoticeController%E6%8E%A8%E9%80%81.png" alt="NoticeController 推送"></p> <p>本质上，它替代了方案一的 DemoWebSocketMessageListener 类，走 HTTP 上行消息，替代 WebSocket 上行消息。</p> <div class="custom-block tip"><p class="custom-block-title">疑问：WebSocketSenderApi 是什么？</p> <p>它是由 <code>yudao-module-infra</code> 对 WebSocketMessageSender 的封装，因为只有它（<code>yudao-module-infra</code>）可以访问到 WebSocketMessageSender 的实现类，所以需要通过 API 的方式，暴露给其它模块使用。</p> <p>这也是为什么 <code>yudao-module-system</code> 模块，需要引入 <code>yudao-module-infra-api</code> 依赖的原因。</p></div> <h4 id="_2-2-2-前端代码"><a href="#_2-2-2-%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81" class="header-anchor">#</a> 2.2.2 前端代码</h4> <p>【相同】① 建立 WebSocket 连接，和方案一相同，不重复截图。</p> <p>【不同】② 发送 HTTP 消息，如下图所示：</p> <p><img src="/img/WebSocket/%E5%85%AC%E5%91%8A%E9%80%9A%E7%9F%A5%E7%9A%84%E5%89%8D%E7%AB%AF%E8%B0%83%E7%94%A8.png" alt="HTTP 发送消息"></p> <p>本质上，它替代了方案一的 WebSocket 上行消息，走 HTTP 上行消息。</p> <p>【相同】③ 接收 WebSocket 消息，和方案一相同，不重复截图。</p> <h3 id="_2-3-如何选择"><a href="#_2-3-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9" class="header-anchor">#</a> 2.3 如何选择？</h3> <p>我个人是倾向于方案二的，使用 HTTP 上行消息，使用 WebSocket 下行消息。原因如下：</p> <p>① <code>yudao-module-infra</code> 扮演一个 WebSocket 服务的角色，可以通过它来主动发送（下行）消息给前端。这样，未来如果使用 MQTT 中间件（例如说，EMQX、阿里云 MQTT、腾讯云 MQTT 等）替换现有 WebSocket 也比较方便。</p> <p>② HTTP 上行消息，相比 WebSocket 上行消息来说，更加方便，也比较符合我们的编码习惯。</p> <p>③ 在微服务架构下，多个服务是拆分开的，无法提供相同的 WebSocket 连接。例如说，<code>yudao-module-infra</code> 和 <code>yudao-module-system</code> 两个服务都需要有 WebSocket 推送能力时，需要前端分别连接它们两个服务。</p> <p>考虑到 <code>ruoyi-vue-pro</code> 和 <code>yudao-cloud</code> 架构的统一性，还是只让 <code>yudao-module-infra</code> 提供 WebSocket 服务：</p> <ul><li>前端连接 <code>yudao-module-infra</code> 的 WebSocket 服务，其它服务通过 <code>yudao-module-infra</code> 下行消息。</li> <li>前端 HTTP 上行消息时，还是通过 HTTP 调用各个服务。</li></ul> <p>ps：如果你只用 <code>ruoyi-vue-pro</code> 单体架构，不会存在 ③ 的困扰，方案一也没问题。</p> <h2 id="_3-实战案例"><a href="#_3-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B" class="header-anchor">#</a> 3. 实战案例</h2> <p>① <a href="/mall/kefu/">《商城 —— 在线客服》</a></p> <p>one more thing~ 后续我们会使用 WebSocket 实现 IM 即时通信功能，敬请期待。</p></div></div>
    </div>
</body>
</html>